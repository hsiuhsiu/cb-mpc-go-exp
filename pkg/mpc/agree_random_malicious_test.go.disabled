package mpc

import (
	"context"
	"strings"
	"sync"
	"testing"
	"time"
)

// Helper function to run protocol with timeout
func runWithTimeout(t *testing.T, timeout time.Duration, fn func()) bool {
	done := make(chan struct{})
	go func() {
		fn()
		close(done)
	}()

	select {
	case <-done:
		return true // Completed
	case <-time.After(timeout):
		return false // Timed out
	}
}

// TestAgreeRandom2PC_MaliciousDropAllSends tests when one party drops all outgoing messages
func TestAgreeRandom2PC_MaliciousDropAllSends(t *testing.T) {
	t.Skip("This test intentionally blocks - run with -run=MaliciousDropAllSends to test timeout behavior")

	maliciousParty := 0
	sessions := NewMaliciousNetwork(2, maliciousParty, MaliciousBehavior{
		DropAllSends: true,
	})

	bitLen := 256
	ctx := context.Background()

	var wg sync.WaitGroup
	errs := make([]error, 2)

	completed := runWithTimeout(t, 1*time.Second, func() {
		for i := 0; i < 2; i++ {
			wg.Add(1)
			go func(partyIndex int) {
				defer wg.Done()
				_, err := AgreeRandom2PC(ctx, sessions[partyIndex], bitLen)
				errs[partyIndex] = err
			}(i)
		}
		wg.Wait()
	})

	if !completed {
		// Expected: protocol blocks because malicious party doesn't send
		t.Log("✅ Protocol correctly blocked - honest party waiting for messages from malicious party")
	} else {
		t.Logf("Protocol completed: party0=%v, party1=%v", errs[0], errs[1])
	}
}

// TestAgreeRandom2PC_MaliciousCorruptMessages tests when one party corrupts messages
func TestAgreeRandom2PC_MaliciousCorruptMessages(t *testing.T) {
	maliciousParty := 1
	sessions := NewMaliciousNetwork(2, maliciousParty, MaliciousBehavior{
		CorruptMessages: true,
	})

	bitLen := 256
	ctx := context.Background()

	var wg sync.WaitGroup
	results := make([][]byte, 2)
	errs := make([]error, 2)

	completed := runWithTimeout(t, 2*time.Second, func() {
		for i := 0; i < 2; i++ {
			wg.Add(1)
			go func(partyIndex int) {
				defer wg.Done()
				result, err := AgreeRandom2PC(ctx, sessions[partyIndex], bitLen)
				results[partyIndex] = result
				errs[partyIndex] = err
			}(i)
		}
		wg.Wait()
	})

	if !completed {
		t.Log("✅ Protocol timed out (expected when one party detects corruption but other hangs)")
		return
	}

	// Protocol should either:
	// 1. Fail completely (preferred)
	// 2. Succeed but parties get different values (detectable)

	bothSucceeded := errs[0] == nil && errs[1] == nil
	if bothSucceeded {
		// If both succeeded, they should NOT have the same value
		// (corrupted messages should lead to different outcomes)
		if len(results[0]) > 0 && len(results[1]) > 0 {
			if bytesEqual(results[0], results[1]) {
				t.Error("Both parties succeeded with same value despite message corruption - this should not happen")
			} else {
				t.Logf("Parties got different values (corruption detected): %x vs %x", results[0][:min(8, len(results[0]))], results[1][:min(8, len(results[1]))])
			}
		}
	} else {
		// At least one party failed, which is acceptable
		t.Logf("Protocol correctly failed: party0=%v, party1=%v", errs[0], errs[1])
	}
}

// TestAgreeRandom2PC_MaliciousSendGarbage tests when one party sends garbage data
func TestAgreeRandom2PC_MaliciousSendGarbage(t *testing.T) {
	maliciousParty := 0
	sessions := NewMaliciousNetwork(2, maliciousParty, MaliciousBehavior{
		SendGarbage: true,
	})

	bitLen := 128
	ctx := context.Background()

	var wg sync.WaitGroup
	errs := make([]error, 2)

	for i := 0; i < 2; i++ {
		wg.Add(1)
		go func(partyIndex int) {
			defer wg.Done()
			_, err := AgreeRandom2PC(ctx, sessions[partyIndex], bitLen)
			errs[partyIndex] = err
		}(i)
	}

	wg.Wait()

	// At least one party should fail when receiving garbage
	if errs[0] == nil && errs[1] == nil {
		t.Error("Expected protocol to fail when one party sends garbage")
	} else {
		t.Logf("Protocol correctly failed: party0=%v, party1=%v", errs[0], errs[1])
	}
}

// TestAgreeRandom2PC_MaliciousSendEmptyMessages tests when one party sends empty messages
func TestAgreeRandom2PC_MaliciousSendEmptyMessages(t *testing.T) {
	maliciousParty := 1
	sessions := NewMaliciousNetwork(2, maliciousParty, MaliciousBehavior{
		SendEmptyMessages: true,
	})

	bitLen := 256
	ctx := context.Background()

	var wg sync.WaitGroup
	errs := make([]error, 2)

	for i := 0; i < 2; i++ {
		wg.Add(1)
		go func(partyIndex int) {
			defer wg.Done()
			_, err := AgreeRandom2PC(ctx, sessions[partyIndex], bitLen)
			errs[partyIndex] = err
		}(i)
	}

	wg.Wait()

	// Protocol should fail when receiving empty messages
	if errs[0] == nil && errs[1] == nil {
		t.Error("Expected protocol to fail when one party sends empty messages")
	} else {
		t.Logf("Protocol correctly failed: party0=%v, party1=%v", errs[0], errs[1])
	}
}

// TestAgreeRandom2PC_MaliciousSendWrongSize tests when one party sends truncated messages
func TestAgreeRandom2PC_MaliciousSendWrongSize(t *testing.T) {
	maliciousParty := 0
	sessions := NewMaliciousNetwork(2, maliciousParty, MaliciousBehavior{
		SendWrongSize: true,
	})

	bitLen := 512
	ctx := context.Background()

	var wg sync.WaitGroup
	errs := make([]error, 2)

	for i := 0; i < 2; i++ {
		wg.Add(1)
		go func(partyIndex int) {
			defer wg.Done()
			_, err := AgreeRandom2PC(ctx, sessions[partyIndex], bitLen)
			errs[partyIndex] = err
		}(i)
	}

	wg.Wait()

	// Protocol should fail when receiving wrong-sized messages
	if errs[0] == nil && errs[1] == nil {
		t.Error("Expected protocol to fail when one party sends wrong-sized messages")
	} else {
		t.Logf("Protocol correctly failed: party0=%v, party1=%v", errs[0], errs[1])
	}
}

// TestAgreeRandom2PC_MaliciousEarlyTermination tests when one party stops mid-protocol
func TestAgreeRandom2PC_MaliciousEarlyTermination(t *testing.T) {
	maliciousParty := 1
	sessions := NewMaliciousNetwork(2, maliciousParty, MaliciousBehavior{
		FailAfterNSends: 1, // Fail after first send
	})

	bitLen := 256
	ctx := context.Background()

	var wg sync.WaitGroup
	errs := make([]error, 2)

	for i := 0; i < 2; i++ {
		wg.Add(1)
		go func(partyIndex int) {
			defer wg.Done()
			_, err := AgreeRandom2PC(ctx, sessions[partyIndex], bitLen)
			errs[partyIndex] = err
		}(i)
	}

	wg.Wait()

	// Malicious party should fail after N sends
	if errs[maliciousParty] == nil {
		t.Error("Expected malicious party to fail after early termination")
	}

	// Honest party should also eventually fail (timeout or receive error)
	honestParty := 1 - maliciousParty
	if errs[honestParty] == nil {
		t.Error("Expected honest party to fail when peer terminates early")
	}

	t.Logf("Both parties correctly failed: party0=%v, party1=%v", errs[0], errs[1])
}

// TestAgreeRandom2PC_MaliciousFlipBits tests when one party flips bits in messages
func TestAgreeRandom2PC_MaliciousFlipBits(t *testing.T) {
	maliciousParty := 0
	sessions := NewMaliciousNetwork(2, maliciousParty, MaliciousBehavior{
		FlipRandomBits: true,
	})

	bitLen := 256
	ctx := context.Background()

	var wg sync.WaitGroup
	results := make([][]byte, 2)
	errs := make([]error, 2)

	for i := 0; i < 2; i++ {
		wg.Add(1)
		go func(partyIndex int) {
			defer wg.Done()
			result, err := AgreeRandom2PC(ctx, sessions[partyIndex], bitLen)
			results[partyIndex] = result
			errs[partyIndex] = err
		}(i)
	}

	wg.Wait()

	// Protocol should either fail or produce different values
	bothSucceeded := errs[0] == nil && errs[1] == nil
	if bothSucceeded && len(results[0]) > 0 && len(results[1]) > 0 {
		if bytesEqual(results[0], results[1]) {
			t.Error("Parties should not agree when messages are corrupted")
		} else {
			t.Logf("Bit flipping correctly caused disagreement")
		}
	} else if !bothSucceeded {
		t.Logf("Protocol correctly failed due to bit flipping")
	}
}

// TestAgreeRandomMPC_MaliciousThreeParties tests multi-party with one malicious party
func TestAgreeRandomMPC_MaliciousThreeParties(t *testing.T) {
	testCases := []struct {
		name            string
		maliciousParty  int
		behavior        MaliciousBehavior
		shouldFailOrDiffer bool
	}{
		{
			name:           "party 0 drops sends",
			maliciousParty: 0,
			behavior:       MaliciousBehavior{DropAllSends: true},
			shouldFailOrDiffer: true,
		},
		{
			name:           "party 1 corrupts messages",
			maliciousParty: 1,
			behavior:       MaliciousBehavior{CorruptMessages: true},
			shouldFailOrDiffer: true,
		},
		{
			name:           "party 2 sends garbage",
			maliciousParty: 2,
			behavior:       MaliciousBehavior{SendGarbage: true},
			shouldFailOrDiffer: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			sessions := NewMaliciousNetwork(3, tc.maliciousParty, tc.behavior)

			bitLen := 128
			ctx := context.Background()

			var wg sync.WaitGroup
			results := make([][]byte, 3)
			errs := make([]error, 3)

			for i := 0; i < 3; i++ {
				wg.Add(1)
				go func(partyIndex int) {
					defer wg.Done()
					result, err := AgreeRandomMPC(ctx, sessions[partyIndex], bitLen)
					results[partyIndex] = result
					errs[partyIndex] = err
				}(i)
			}

			wg.Wait()

			// Check if any party failed
			anyFailed := false
			for i := 0; i < 3; i++ {
				if errs[i] != nil {
					anyFailed = true
					break
				}
			}

			// Check if parties disagree
			partiesDisagree := false
			if !anyFailed {
				for i := 1; i < 3; i++ {
					if !bytesEqual(results[0], results[i]) {
						partiesDisagree = true
						break
					}
				}
			}

			if tc.shouldFailOrDiffer {
				if !anyFailed && !partiesDisagree {
					t.Errorf("Expected protocol to fail or parties to disagree, but all succeeded with same value")
				} else {
					if anyFailed {
						t.Logf("Protocol correctly failed")
					}
					if partiesDisagree {
						t.Logf("Parties correctly disagreed")
					}
				}
			}
		})
	}
}

// TestAgreeRandomMPC_MultipleHonestPartiesVsOneMalicious tests that honest majority still works
func TestAgreeRandomMPC_MultipleHonestPartiesVsOneMalicious(t *testing.T) {
	// With 5 parties, 1 malicious should not prevent protocol execution
	// (though it might cause failures depending on the protocol's security model)
	sessions := NewMaliciousNetwork(5, 0, MaliciousBehavior{
		CorruptMessages: true,
	})

	bitLen := 256
	ctx := context.Background()

	var wg sync.WaitGroup
	results := make([][]byte, 5)
	errs := make([]error, 5)

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(partyIndex int) {
			defer wg.Done()
			result, err := AgreeRandomMPC(ctx, sessions[partyIndex], bitLen)
			results[partyIndex] = result
			errs[partyIndex] = err
		}(i)
	}

	wg.Wait()

	// Count how many parties succeeded
	successCount := 0
	for i := 0; i < 5; i++ {
		if errs[i] == nil {
			successCount++
		}
	}

	t.Logf("Out of 5 parties (1 malicious), %d succeeded", successCount)

	// Check if successful parties agree
	if successCount > 1 {
		var firstSuccess int
		for i := 0; i < 5; i++ {
			if errs[i] == nil {
				firstSuccess = i
				break
			}
		}

		allAgree := true
		for i := firstSuccess + 1; i < 5; i++ {
			if errs[i] == nil && !bytesEqual(results[firstSuccess], results[i]) {
				allAgree = false
				t.Errorf("Successful parties disagree: party %d vs party %d", firstSuccess, i)
			}
		}

		if allAgree {
			t.Logf("All successful parties agreed on the same value")
		}
	}
}

// TestAgreeRandom2PC_WithTimeout tests timeout behavior
func TestAgreeRandom2PC_WithTimeout(t *testing.T) {
	// This test shows how timeouts would work with context
	sessions := NewMaliciousNetwork(2, 1, MaliciousBehavior{
		DropAllSends: true, // Malicious party won't send
	})

	bitLen := 256
	ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
	defer cancel()

	var wg sync.WaitGroup
	errs := make([]error, 2)

	for i := 0; i < 2; i++ {
		wg.Add(1)
		go func(partyIndex int) {
			defer wg.Done()
			_, err := AgreeRandom2PC(ctx, sessions[partyIndex], bitLen)
			errs[partyIndex] = err
		}(i)
	}

	// Wait with a timeout
	done := make(chan struct{})
	go func() {
		wg.Wait()
		close(done)
	}()

	select {
	case <-done:
		// Good - protocol terminated
		t.Logf("Protocol terminated: party0=%v, party1=%v", errs[0], errs[1])
	case <-time.After(5 * time.Second):
		t.Error("Protocol did not terminate within timeout - possible deadlock")
	}
}

// TestAgreeRandom2PC_ReplayAttack tests message replay resistance
func TestAgreeRandom2PC_ReplayAttack(t *testing.T) {
	sessions := NewMaliciousNetwork(2, 0, MaliciousBehavior{
		ReplayFirstMessage: true,
	})

	bitLen := 256
	ctx := context.Background()

	var wg sync.WaitGroup
	results := make([][]byte, 2)
	errs := make([]error, 2)

	for i := 0; i < 2; i++ {
		wg.Add(1)
		go func(partyIndex int) {
			defer wg.Done()
			result, err := AgreeRandom2PC(ctx, sessions[partyIndex], bitLen)
			results[partyIndex] = result
			errs[partyIndex] = err
		}(i)
	}

	wg.Wait()

	// Replay attacks should cause protocol failure or disagreement
	bothSucceeded := errs[0] == nil && errs[1] == nil
	if bothSucceeded && len(results[0]) > 0 && len(results[1]) > 0 {
		if bytesEqual(results[0], results[1]) {
			t.Log("Note: Parties agreed despite replay attack - protocol may be replay-resistant or attack was ineffective")
		} else {
			t.Log("Replay attack caused disagreement (protocol detected the attack)")
		}
	} else {
		t.Log("Protocol correctly failed during replay attack")
	}
}

// Helper function
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// TestMaliciousSession_BehaviorIsolation ensures malicious behavior doesn't affect other parties' sessions
func TestMaliciousSession_BehaviorIsolation(t *testing.T) {
	// Create network where party 0 is malicious
	sessions := NewMaliciousNetwork(3, 0, MaliciousBehavior{
		DropAllSends: true,
	})

	// Verify that only party 0 has the malicious wrapper
	maliciousSession, ok := sessions[0].(*MaliciousSession)
	if !ok {
		t.Fatal("Party 0 should be a MaliciousSession")
	}

	if !maliciousSession.behavior.DropAllSends {
		t.Error("Malicious behavior not properly set")
	}

	// Verify other parties are not malicious
	for i := 1; i < 3; i++ {
		if _, ok := sessions[i].(*MaliciousSession); ok {
			t.Errorf("Party %d should not be malicious", i)
		}
	}
}

// TestMaliciousSession_ErrorMessages verifies error messages are descriptive
func TestMaliciousSession_ErrorMessages(t *testing.T) {
	mockSession := NewMockNetwork(2)[0]

	testCases := []struct {
		name            string
		behavior        MaliciousBehavior
		operation       func(Session) error
		expectedErrText string
	}{
		{
			name:     "fail after N sends",
			behavior: MaliciousBehavior{FailAfterNSends: 1},
			operation: func(s Session) error {
				_ = s.Send(1, []byte("msg1"))
				return s.Send(1, []byte("msg2"))
			},
			expectedErrText: "failing after N sends",
		},
		{
			name:     "fail after N receives",
			behavior: MaliciousBehavior{FailAfterNReceives: 1},
			operation: func(s Session) error {
				_, err := s.Receive(1)
				return err
			},
			expectedErrText: "failing after N receives",
		},
		{
			name:     "drop all receives",
			behavior: MaliciousBehavior{DropAllReceives: true},
			operation: func(s Session) error {
				_, err := s.Receive(1)
				return err
			},
			expectedErrText: "dropping all receives",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			malicious := NewMaliciousSession(mockSession, tc.behavior)
			err := tc.operation(malicious)

			if err == nil {
				t.Error("Expected error but got nil")
			} else if !strings.Contains(err.Error(), tc.expectedErrText) {
				t.Errorf("Expected error containing %q, got: %v", tc.expectedErrText, err)
			}
		})
	}
}
